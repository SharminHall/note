## 浏览器缓存
### 强缓存

http1.0 `Expires` 过期时间点。本地时间可能会更改导致与服务器不一致

http1.1 `Cache-Control`：
  1. max-age: 过期时长
  2. public: 服务器和客户端都可缓存
  3. private: 仅客户端可缓存
  4. s-maxage: 服务器缓存时长
  5. no-cache: 跳过强缓存，到协商缓存
  6. no-store: 不缓存
  7. max-stale: 最大过期时间，可以接收超出超时期间的响应消息
  8. min-fresh: 最小新鲜度，可以接收响应时间小于当前时间加上指定时间的响应

### 协商缓存
  1. Last-Modified / If-Modified-Since 服务器最后修改时间。缺点1.无法感知一秒以内多次修改更新；2.编辑但未修改，依然会造成缓存失效
  2. E-Tag / If-None-Match 服务器内容修改标志

两者对比：性能上Last-Modified占优；精确度上E-Tag占优；E-Tag优先级高

### 缓存位置

1. Service Worker：运行在浏览器背后的独立线程。PWA的核心技术。
2. Memory Cache：内存。
3. Disk Cache：硬盘缓存。
4. Push Cache：推送缓存（HTTP/2），只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂。

## 浏览器的本地存储

### cookie

无状态的http需要一个状态标记的产物，以便让服务器知道访问者是谁。

缺点：

  1. 容量：4KB的容量极小
  2. 性能：域名绑定，任一该域名下的请求都会携带所有该域名下的cookie
  3. 安全：CSRF(Cross-site request forgery), 即跨站请求伪造。

### localStorage

较大容量的持久存储方式

### sessionStorage

较大容量的会话级别的存储（窗口关闭则消失）

### indexedDB

运行在浏览器中的非关系型数据库。

## 浏览器渲染流程（从输入url到页面呈现）

### 浏览器进程 -- 预知识

1. 浏览器主进程 -- 界面显示、用户交互、子进程管理，同时提供存储等功能
2. 网络进程 -- 专门处理网络请求
3. 渲染进程 -- 渲染页面（V8引擎和Blink排版引擎）
4. 插件进程 -- 浏览器插件
5. GPU进程 -- 界面绘制，3D加速

### 资源文件拉取 -- 导航流程

1. 浏览器构建url对应请求
2. 网络进程查看资源是否被强缓存，是的话，直接返回资源给浏览器进程，结束这一段
3. DNS域名解析，去找对应ip，域名解析也会被缓存，如果有，可直接使用不需要再去解析
4. 等待TCP队列(一个域名最多存在6个) -> 建立TCP连接（三次握手）
5. HTTP请求
6. 服务器返回对应资源，网络进程解析响应头：（结束后可断开TCP，除非头部信息中含有`Connection:Keep-Alive`，则保持长连接。）
    1. 网络进程识别状态码301或者302：重定向操作。则会重新打开新的header中`location`字段对应网址，重复上述操作。
    2. 识别数据类型，`Content-Type`字段。
    3. 准备渲染进程：一个标签页一个渲染进程，如果同站点之间开辟新的标签页则共用（process-per-site-instance）
    4. 提交文档：浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程。
        - 浏览器进程接收网络进程的响应头数据，告诉渲染进程去向网络进程索取数据（提交文档通知）
        - 渲染进程收到通知，和网络进程建立传输数据的“管道”
        - 渲染进程拿到数据后，告诉浏览器进程OK（确认提交消息）
        - 浏览器确认后，更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。

### 渲染 -- 渲染流程

渲染进程分为渲染主线程和合成线程

渲染主线程执行：

#### 1. 构建DOM树

将html文件转换成DOM————浏览器能够理解的结构

#### 2. 计算样式

1. 将css样式转换成styleSheets————浏览器能够理解的结构
2. 转换样式表中的属性值，使其标准化
3. 计算出 DOM 树中每个节点的具体样式（遵守 CSS 的继承和层叠两个规则）。生成`ComputedStyle`

#### 3. 生成布局树

计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。

#### 4. 创建布局树

在显示之前，还要额外地构建一棵只包含`可见元素`布局树。

#### 5. 布局计算

计算布局树的位置，返回带样式的布局树

#### 6. 建立图层

渲染引擎为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。

可以把布局树理解为二维的，图层树理解为三维的（类比ps的图层概念）。

图层依据规则：元素拥有层叠上下文的属性或者需要被剪裁

#### 7. 生成绘制队列

顺序生成绘制指令队列。

绘制队列生成完毕，渲染主线程将会告知（commmit）合成线程，合成线程接收到绘制队列后：

#### 8. 生成图块

合成线程会将图层划分为一个个小的`图块（tile）`，图块大小默认`256x256` 或者 `512x512`。

#### 9. 图块装换成位图

合成线程将视窗（屏幕可见区域）附近的图块位图优先转换为`位图`，这个操作叫做`栅格化`。渲染进程维护了一个栅格化的线程池。

栅格化过程如果使用`GPU进程`加速，则生成位图实在GPU进程中执行并存储在GPU内存之中。

#### 10. 合成和显示 -- 最后

所有图块都被光栅化后，合成线程就告诉浏览器进程可以开始画图了（DrawQuad）。浏览器接收到该信息，则将页面内容绘制到内存中，最后再将内容显示在屏幕上。

## 浏览器的回流与重绘

### 回流（重排）

触发了DOM元素几何位置的属性，比如宽高，浮动，定位等都会引起回流。导致浏览器整个渲染过程从生成样式表开始重新走了一遍。

### 重绘

更新了DOM元素的绘制属性，比如背景色，字体颜色等，会引起重绘。重绘也是从计算样式表开始，但是会跳过生成布局树和图层树的步骤，直接去生成绘制命令，走一遍渲染过程

### 直接合成

直接合成就是更改了既不要布局也不要绘制，如transform动画属性，则生成计算样式表后，跳过布局树和图层树和绘制列表的生成，直接去合成线程生成图块并栅格化操作开始。性能是最高的。
